00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
<<<<<<< HEAD
Created On: 15/03/2015 1:39:27 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11  
00001000                            12          
00001000  6000 0026                 13          bra     loadfile
00001004                            14  return
00001004  41F9 00002000             15          lea     A,a0
0000100A  43F9 00002000             16          lea     A,a1
00001010  5449                      17          addq.w  #2,a1
00001012  4240                      18          clr.w   d0
00001014  4241                      19          clr.w   d1
00001016  4242                      20          clr.w   d2
00001018  4243                      21          clr.w   d3
0000101A  3239 00002100             22          move.w  arraysize,d1
00001020  6000 0074                 23          bra     sort
00001024                            24  
00001024                            25  
00001024                            26  finished:        
00001024                            27  
00001024  FFFF FFFF                 28      SIMHALT             ; halt simulator
00001028                            29      
00001028                            30  loadfile
00001028  43F9 00002106             31              lea     dir,a1
0000102E  303C 0033                 32              move.w  #51,d0
00001032  4E4F                      33              trap    #15
00001034                            34  
00001034                            35  
00001034  7402                      36              move.l  #2,d2
00001036  45F9 00002000             37              lea     A,a2
0000103C  303C 0035                 38  loop1       move.w  #53,d0
00001040  4E4F                      39              trap    #15
00001042                            40  
00001042  B07C 0001                 41              cmp.w   #1,d0
00001046  6700 000C                 42              beq     doneloop1
0000104A                            43              
0000104A  0C11 002D                 44              cmp.b   #$2D,(a1)
0000104E  6600 0010                 45              bne     addtoarray
00001052  60E8                      46              bra     loop1
00001054                            47  
00001054                            48  
00001054                            49  doneloop1
00001054                            50  
00001054  33C4 00002100             51              move.w      d4,arraysize
0000105A  7032                      52              move.l      #50,d0
0000105C  4E4F                      53              trap        #15
0000105E                            54              
0000105E  60A4                      55              bra return
00001060                            56  
00001060                            57  addtoarray
00001060  2491                      58              move.l      (a1),(a2)
00001062  045A 3030                 59              sub.w       #$3030,(a2)+
00001066  5244                      60              addq.w      #1,d4
00001068  60D2                      61              bra         loop1
0000106A                            62              
0000106A  41F9 00002000             63  resetaddressregisters       lea          A,a0
00001070  43F9 00002000             64                              lea          A,a1
00001076  5449                      65                              addq.w      #2,a1
00001078  6000 0030                 66                              bra         loop
0000107C  5448                      67  advance     addq.w  #2,a0
0000107E  5449                      68              addq.w  #2,a1
00001080  6000 0038                 69              bra     afteradvance
00001084                            70              
00001084  33D0 00002102             71  swap        move.w  (a0),temp1
0000108A  3091                      72              move.w  (a1),(a0)
0000108C  32B9 00002102             73              move.w  temp1,(a1)
00001092  6000 0024                 74              bra     afterswap
00001096                            75                              
00001096  B079 00002100             76  sort        cmp.w   arraysize,d0
0000109C  6786                      77              beq     finished
0000109E  3239 00002100             78              move.w  arraysize,d1    
000010A4  9240                      79              sub.w   d0,d1
000010A6                            80  
000010A6  5341                      81              subq.w  #1,d1
000010A8  60C0                      82              bra     resetaddressregisters
000010AA                            83  
000010AA                            84  
000010AA  4A41                      85  loop        tst.w   d1
000010AC  6700 0010                 86              beq     finishedloop
000010B0                            87              
000010B0  3410                      88              move.w  (a0),d2
000010B2  3611                      89              move.w  (a1),d3
000010B4                            90  
000010B4  B642                      91              cmp.w   d2,d3
000010B6  6DCC                      92              blt     swap
000010B8                            93  afterswap
000010B8  60C2                      94             bra     advance
000010BA                            95  
000010BA                            96  
000010BA                            97  afteradvance            
000010BA  5341                      98              subq.w  #1,d1
000010BC  60EC                      99              bra     loop
000010BE                           100  
000010BE  5240                     101  finishedloop    addq.w  #1,d0
000010C0  60D4                     102                  bra     sort
000010C2                           103  
000010C2                           104  
000010C2                           105  
000010C2                           106  
000010C2                           107  * Put variables and constants here    
00002000                           108      org     $2000
00002000                           109  A            ds.w    20
00002028                           110  
00002028                           111  
00002100                           112      org     $2100
00002100= 0005                     113  arraysize    dc.w    5
00002102= 0000                     114  temp1        dc.w    0
00002104= 0000                     115  temp2        dc.w    0
00002106= 696E7075 74000000 ...    116  dir          dc.l   'input',0
00002112= 0000                     117  buffer       dc.w   0
00002114                           118  
00002114                           119      END    START        ; last line of source
=======
Created On: 2015-04-14 8:57:20 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  CPS310, Lab 4
00000000                             3  * Written by :  Sam Dindyal
00000000                             4  * Date       :  April 2015
00000000                             5  * Description:  An M68000 program which writes an unsorted
00000000                             6  *               array of signed integers to a file. It then
00000000                             7  *               reads the file it created back into an 
00000000                             8  *               array and sorts it using bubble sort.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:           
00001000  4EB9 000010E8             12      jsr     backup_registers      
00001006  4EB9 00001096             13      jsr     write_array_to_file
0000100C  4EB9 0000110E             14      jsr     restore_registers
00001012                            15      
00001012  4EB9 000010E8             16      jsr     backup_registers
00001018  4EB9 000010BC             17      jsr     read_array_from_file
0000101E  4EB9 00001034             18      jsr     sort
00001024  4EB9 00001096             19      jsr     write_array_to_file
0000102A  4EB9 0000110E             20      jsr     restore_registers
00001030                            21   
00001030  FFFF FFFF                 22      SIMHALT
00001034                            23      
00001034                            24  * Sort the array stored in "array" using bubble sort
00001034                            25  sort    ; Clear d0
00001034  4280                      26          clr.l   d0  ; Using d0 as the counter for the outer loop
00001036                            27  outer_loop      ; Loop until d0 and the array size are equal
00001036  B039 00002014             28                  cmp.b   array_size,d0
0000103C  6700 0024                 29                  beq     done_outer_loop 
00001040                            30                  
00001040                            31                  ;Move the array size into d1
00001040  1239 00002014             32                  move.b  array_size,d1   ; Using d1 as the counter for the inner loop
00001046  48C1                      33                  ext.l   d1
00001048  5381                      34                  sub.l   #1,d1               
0000104A                            35                  
0000104A                            36                  ; Subtract the current counter from the outer loop from the counter of the inner loop
0000104A  9280                      37                  sub.l   d0,d1                
0000104C                            38                  
0000104C                            39                  ; Increment the counter for the outer loop
0000104C  5280                      40                  add.l   #1,d0
0000104E                            41  
0000104E                            42                  ; Reset the address registers a0 and a1
0000104E  4EB9 00001074             43                  jsr     set_address_registers                
00001054                            44          
00001054                            45  inner_loop:     ; Loop until d1 is 0
00001054  4A81                      46                  tst.l   d1
00001056  6FDE                      47                  ble     outer_loop
00001058                            48          
00001058                            49                  ; Decrement the counter for the inner loop
00001058  5381                      50                  sub.l   #1,d1
0000105A                            51          
0000105A                            52                  ; Compare the two current values of the array
0000105A  B189                      53                  cmpm.l  (a1)+,(a0)+
0000105C                            54                  
0000105C                            55                  ; Swap if the succeeding value is larger
0000105C  6E00 0006                 56                  bgt     swap
00001060                            57                  
00001060                            58                  ; Branch to the inner loop 
00001060  60F2                      59                  bra     inner_loop
00001062                            60          
00001062                            61  done_outer_loop:    ; Return to sender
00001062  4E75                      62                      rts
00001064                            63              
00001064                            64  * Swap the values at the memory address locations of a0 and a1 with the use of the stack.
00001064                            65  swap
00001064                            66          ; Move a0 to the stack with auto decrement
00001064  2F28 FFFC                 67          move.l  -4(a0),-(sp)
00001068                            68          
00001068                            69          ; Move the value a1 into the address of a0
00001068  2169 FFFC FFFC            70          move.l  -4(a1),-4(a0)
0000106E                            71          
0000106E                            72          ; Move the old value from a0 from the stack to the address of a1
0000106E  235F FFFC                 73          move.l  (sp)+, -4(a1)
00001072                            74          
00001072                            75          ; Branch back to the inner loop
00001072  60E0                      76          bra     inner_loop
00001074                            77          
00001074                            78  * Set the address registers, a0 and a1, to the first and second element of "array" respectively.
00001074                            79  set_address_registers
00001074                            80                            ; Load the effective address of the array into a0
00001074  41F9 00002000             81                            lea       array,a0
0000107A                            82                            
0000107A                            83                            ; Load the effective address of the array into a1
0000107A  43F9 00002000             84                            lea       array,a1
00001080                            85                            
00001080                            86                            ; Advance a1 by one long
00001080  5889                      87                            add.l     #4,a1
00001082                            88                            
00001082                            89                            ; Return to sender
00001082  4E75                      90                            rts   
00001084                            91                            
00001084                            92  * Open a file denoted by the "file" constant.
00001084                            93  open_file
00001084                            94              ; Load the effective address of "file" into a1
00001084  43F9 00002015             95              lea     file,a1
0000108A                            96              
0000108A                            97              ; Open a new file with the appropriate trap sequence
0000108A  7034                      98              move.l  #52,d0
0000108C  4E4F                      99              trap    #15
0000108E                           100              
0000108E                           101              ; Return to sender
0000108E  4E75                     102              rts
00001090                           103              
00001090                           104  * Close all open files.
00001090                           105  close_file  ; Close all open files
00001090  7032                     106              move.l  #50,d0
00001092  4E4F                     107              trap    #15
00001094                           108              
00001094                           109              ; Return to sender
00001094  4E75                     110              rts
00001096                           111              
00001096                           112  * Write "array" to "file".
00001096                           113  write_array_to_file
00001096                           114                          ; Open a new file
00001096  4EB8 1084                115                          jsr     open_file
0000109A                           116                          
0000109A                           117                          ; Load the effective address of the array into a1
0000109A  43F9 00002000            118                          lea     array,a1    ; Use the array as the buffer register
000010A0                           119                          
000010A0                           120                          ; Prepare registers and counter for reading in "file"
000010A0  7404                     121                          move.l  #4,d2
000010A2  1639 00002014            122                          move.b  array_size,d3
000010A8  48C3                     123                          ext.l   d3
000010AA                           124                          
000010AA                           125  write_loop:     ; Loop until d3 is 0
000010AA  4A83                     126                  tst.l   d3
000010AC  6700 000C                127                  beq     done_write_loop
000010B0                           128                  
000010B0                           129                  ; Write to "file" from "array"
000010B0  7036                     130                  move.l  #54,d0
000010B2  4E4F                     131                  trap    #15
000010B4                           132                  
000010B4                           133                  ; Traverse through the array
000010B4  5889                     134                  add.l   #4,a1
000010B6                           135                  
000010B6                           136                  ; Decrement the counter
000010B6  5383                     137                  sub.l   #1,d3
000010B8                           138                  
000010B8                           139                  ; Branch to the write loop
000010B8  60F0                     140                  bra     write_loop
000010BA                           141                  
000010BA                           142  done_write_loop:    ; Return to sender
000010BA  4E75                     143                      rts
000010BC                           144  
000010BC                           145  * Read an array from "file" and store it into "array".
000010BC                           146  read_array_from_file    ; Load the effective address of "file" into a1
000010BC  43F9 00002015            147                          lea     file,a1
000010C2                           148                          
000010C2                           149                          ; Open existing file
000010C2  7033                     150                          move.l  #51,d0
000010C4  4E4F                     151                          trap    #15
000010C6                           152                          
000010C6                           153                          ; Load the effective address of "array" into a1
000010C6  43F9 00002000            154                          lea     array,a1    ; Use a1 as the buffer register
000010CC  1639 00002014            155                          move.b  array_size,d3   ; Use d3 as the counter for the read loop
000010D2  48C3                     156                          ext.l   d3
000010D4                           157                          
000010D4                           158  read_loop:  ; Loop until d3 is 0
000010D4  4A83                     159              tst.l   d3
000010D6  6700 000E                160              beq     done_read_loop 
000010DA                           161                    
000010DA                           162              ; Prepare registers for a read in
000010DA  7404                     163              move.l  #4,d2   ; Reading in size 4 (long size)
000010DC  7035                     164              move.l  #53,d0
000010DE                           165              
000010DE                           166              ; Decrement the counter
000010DE  5383                     167              sub.l   #1,d3
000010E0                           168              
000010E0                           169              ; Read in from file and store into array
000010E0  4E4F                     170              trap    #15
000010E2                           171              
000010E2                           172              ; Advance to the next element in the array
000010E2  5889                     173              add.l   #4,a1
000010E4                           174              
000010E4                           175              ; Branch to the read loop
000010E4  60EE                     176              bra     read_loop
000010E6                           177    
000010E6                           178  done_read_loop:     ; Return to sender
000010E6  4E75                     179                      rts
000010E8                           180                                                  
000010E8                           181  *Backup all registers to the stack using auto decrement
000010E8                           182  backup_registers    ; Backup address registers to stack with auto decrement
000010E8  2F08                     183                      move.l  a0,-(sp)
000010EA  2F09                     184                      move.l  a1,-(sp)
000010EC  2F0A                     185                      move.l  a2,-(sp)
000010EE  2F0B                     186                      move.l  a3,-(sp)
000010F0  2F0C                     187                      move.l  a4,-(sp)
000010F2  2F0D                     188                      move.l  a5,-(sp)
000010F4  2F0E                     189                      move.l  a6,-(sp)
000010F6  2F0F                     190                      move.l  a7,-(sp)
000010F8                           191                      
000010F8                           192                      ; Backup data registers to stack with auto decrement
000010F8  2F00                     193                      move.l  d0,-(sp)
000010FA  2F01                     194                      move.l  d1,-(sp)
000010FC  2F02                     195                      move.l  d2,-(sp)
000010FE  2F03                     196                      move.l  d3,-(sp)
00001100  2F04                     197                      move.l  d4,-(sp)
00001102  2F05                     198                      move.l  d5,-(sp)
00001104  2F06                     199                      move.l  d6,-(sp)
00001106  2F07                     200                      move.l  d7,-(sp)
00001108                           201                      
00001108                           202                      ; Restore the program counter for resumption
00001108  2F2F 0040                203                      move.l  64(sp),-(sp)
0000110C                           204                      
0000110C                           205                      ; Return to sender
0000110C  4E75                     206                      rts
0000110E                           207  
0000110E                           208  * Restore all content to registers using auto increment
0000110E  588F                     209  restore_registers   add.l   #4,sp
00001110                           210  
00001110                           211                     ; Restore content from stack to data registers using auto increment
00001110  2E1F                     212                      move.l  (sp)+,d7
00001112  2C1F                     213                      move.l  (sp)+,d6
00001114  2A1F                     214                      move.l  (sp)+,d5
00001116  281F                     215                      move.l  (sp)+,d4
00001118  261F                     216                      move.l  (sp)+,d3
0000111A  241F                     217                      move.l  (sp)+,d2
0000111C  221F                     218                      move.l  (sp)+,d1
0000111E  201F                     219                      move.l  (sp)+,d0
00001120                           220                      
00001120                           221                      ; Restore content from stack to address registers using auto increment
00001120  2E5F                     222                      move.l  (sp)+,a7
00001122  2C5F                     223                      move.l  (sp)+,a6
00001124  2A5F                     224                      move.l  (sp)+,a5
00001126  285F                     225                      move.l  (sp)+,a4
00001128  265F                     226                      move.l  (sp)+,a3
0000112A  245F                     227                      move.l  (sp)+,a2
0000112C  225F                     228                      move.l  (sp)+,a1
0000112E  205F                     229                      move.l  (sp)+,a0
00001130                           230                      
00001130                           231                      ; Put the stack pointer back for the program counter to resume
00001130  2EAF FFBC                232                      move.l  -68(sp),(sp) 
00001134                           233  
00001134                           234                      ; Return to sender
00001134  4E75                     235                      rts
00001136                           236  
00001136                           237  * Variables and constants
00002000                           238      ORG $2000
00002000= 00000007 00000004 ...    239  array       dc.l    7,4,2,9,8
00002014= 05                       240  array_size  dc.b    5
00002015= 66 69 6C 65 00           241  file        dc.b    'file',0
0000201A                           242  
0000201A                           243      END    START        ; last line of source
>>>>>>> 9fa68c5705b35a5878ff79b0f2a27103e8504905

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
<<<<<<< HEAD
A                   2000
ADDTOARRAY          1060
ADVANCE             107C
AFTERADVANCE        10BA
AFTERSWAP           10B8
ARRAYSIZE           2100
BUFFER              2112
DIR                 2106
DONELOOP1           1054
FINISHED            1024
FINISHEDLOOP        10BE
LOADFILE            1028
LOOP                10AA
LOOP1               103C
RESETADDRESSREGISTERS  106A
RETURN              1004
SORT                1096
START               1000
SWAP                1084
TEMP1               2102
TEMP2               2104
=======
ARRAY               2000
ARRAY_SIZE          2014
BACKUP_REGISTERS    10E8
CLOSE_FILE          1090
DONE_OUTER_LOOP     1062
DONE_READ_LOOP      10E6
DONE_WRITE_LOOP     10BA
FILE                2015
INNER_LOOP          1054
OPEN_FILE           1084
OUTER_LOOP          1036
READ_ARRAY_FROM_FILE  10BC
READ_LOOP           10D4
RESTORE_REGISTERS   110E
SET_ADDRESS_REGISTERS  1074
SORT                1034
START               1000
SWAP                1064
WRITE_ARRAY_TO_FILE  1096
WRITE_LOOP          10AA
>>>>>>> 9fa68c5705b35a5878ff79b0f2a27103e8504905
